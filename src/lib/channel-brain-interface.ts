/**
 * ChannelBrain Interface â€” Worker Brain V2
 *
 * Defines the standardized interface for all Channel Brains (Meta, Google, GA4, Ecommerce).
 * Each Brain analyzes its channel and produces ChannelSignals for the Master Brain to correlate.
 *
 * Architecture:
 * - MetaBrain: Wraps existing DecisionEngine/AlertEngine/CreativeClassifier
 * - GoogleBrain: Analyzes Google Ads efficiency (Phase 4)
 * - GA4Brain: Post-click behavior and landing page diagnostics (Phase 3)
 * - EcommerceBrain: Real sales data from Shopify/TiendaNube (Phase 2)
 * - MasterBrain: Correlates signals across channels (Phase 4)
 */

import { Client } from "@/types";

/**
 * Channel type identifier
 */
export type ChannelType = 'META' | 'GOOGLE' | 'GA4' | 'ECOMMERCE';

/**
 * Data quality assessment for a channel's snapshot
 */
export interface DataQuality {
  /** Fields that returned null/undefined (indicates missing tracking or configuration) */
  fieldsWithNull: string[];
  /** Confidence level in the data quality */
  confidence: 'HIGH' | 'MEDIUM' | 'LOW';
  /** Optional notes about data issues */
  notes?: string;
}

/**
 * Alert generated by a Channel Brain
 *
 * These are channel-specific alerts that get merged into the unified alert stream.
 * The Master Brain may promote/demote severity based on cross-channel correlation.
 */
export interface ChannelAlert {
  /** Unique alert type ID (e.g., "META_HIGH_FREQUENCY") */
  type: string;
  /** Severity level */
  severity: 'CRITICAL' | 'WARNING' | 'INFO';
  /** Human-readable alert message */
  message: string;
  /** Actionable recommendation */
  recommendation: string;
  /** Supporting data for the alert (flexible structure) */
  data: Record<string, unknown>;
}

/**
 * Standardized output from a Channel Brain analysis
 *
 * This interface ensures all Channel Brains speak the same language,
 * making it possible for the Master Brain to correlate signals.
 */
export interface ChannelSignals {
  /** Channel identifier */
  canal: ChannelType;
  /** Client ID this analysis is for */
  clientId: string;
  /** Date range analyzed */
  dateRange: {
    start: string;  // YYYY-MM-DD
    end: string;    // YYYY-MM-DD
  };

  /**
   * Normalized core KPIs (shared vocabulary across channels)
   * Optional fields because not all channels have all metrics
   */
  kpis: {
    costo?: number;         // Total spend
    ingresos?: number;      // Revenue attributed by this channel
    roas?: number;          // Return on Ad Spend
    cpa?: number;           // Cost per acquisition
    conversiones?: number;  // Conversion count
    clicks?: number;        // Click count
    impresiones?: number;   // Impression count
    ctr?: number;           // Click-through rate (%)
  };

  /**
   * Channel-specific alerts
   * These get merged into the global alert stream by ClientSnapshotService
   */
  alerts: ChannelAlert[];

  /**
   * Signals for Master Brain consumption (not shown to user)
   *
   * These are raw values the Master Brain uses for cross-channel correlation:
   * - Meta: frecuencia_promedio, pixel_purchases, has_bleeding_campaigns, etc.
   * - Google: conversiones, is_active, etc.
   * - GA4: tasa_rebote, tasa_checkout_a_compra, clics_organicos, etc.
   * - Ecommerce: ordenes_pagadas, ordenes_reembolsadas, etc.
   *
   * The Master Brain reads these to detect patterns like:
   * - LANDING_DEGRADATION: Meta CTR stable + GA4 rebote high
   * - ATTRIBUTION_DISCREPANCY: (Meta ingresos + Google ingresos) >> Ecommerce ingresos
   */
  signals: Record<string, number | string | boolean | null>;

  /**
   * Data quality assessment
   *
   * Critical for the Master Brain to know which correlations it can trust.
   * Example: Don't run LANDING_DEGRADATION alert if GA4 data quality is LOW.
   */
  dataQuality: DataQuality;
}

/**
 * Abstract base class for all Channel Brains
 *
 * Each Brain implements the analyze() method to:
 * 1. Read its channel's data snapshot
 * 2. Run channel-specific analysis logic
 * 3. Generate alerts according to its brain prompt rules
 * 4. Return standardized ChannelSignals
 *
 * Example usage:
 * ```typescript
 * const metaBrain = new MetaBrain();
 * const signals = await metaBrain.analyze(clientId, dateRange, clientConfig);
 * console.log(signals.kpis.roas);  // 2.5x
 * console.log(signals.alerts.length);  // 3 alerts
 * ```
 */
export abstract class ChannelBrain {
  /**
   * Analyze the channel and produce standardized signals
   *
   * @param clientId - Client to analyze
   * @param dateRange - Date range for analysis (YYYY-MM-DD format)
   * @param clientConfig - Client configuration with targets, thresholds, timezone, etc.
   * @returns ChannelSignals for this channel
   */
  abstract analyze(
    clientId: string,
    dateRange: { start: string; end: string },
    clientConfig: Client
  ): Promise<ChannelSignals>;

  /**
   * Helper: Read snapshot from Firestore for this channel
   *
   * Subclasses implement this to read from their specific cache structure:
   * - MetaBrain: dashbo_snapshots/{clientId}/{date}/meta
   * - GoogleBrain: dashbo_snapshots/{clientId}/{date}/google
   * - GA4Brain: dashbo_snapshots/{clientId}/{date}/ga4
   * - EcommerceBrain: dashbo_snapshots/{clientId}/{date}/ecommerce
   */
  protected abstract readSnapshot(
    clientId: string,
    dateRange: { start: string; end: string }
  ): Promise<any>;

  /**
   * Helper: Extract normalized KPIs from raw data
   */
  protected abstract extractKPIs(data: any): ChannelSignals['kpis'];

  /**
   * Helper: Extract signals for Master Brain
   */
  protected abstract extractSignals(data: any): Record<string, any>;

  /**
   * Helper: Evaluate alert rules and generate ChannelAlerts
   *
   * This typically:
   * 1. Fetches alert rules from brain_prompts/{brainId} in Firestore
   * 2. Evaluates each enabled rule against the data
   * 3. Interpolates message templates with actual values
   * 4. Returns array of ChannelAlert objects
   */
  protected abstract evaluateAlerts(data: any, clientConfig: Client): Promise<ChannelAlert[]>;
}

/**
 * Type alias for backward compatibility
 * ClientConfigV2 is just Client with new optional fields (integraciones, targets, timezone)
 */
export type ClientConfigV2 = Client;
